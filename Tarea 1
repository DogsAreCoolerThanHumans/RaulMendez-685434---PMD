#include <stdio.h>
#include <string.h>

typedef struct Profesor
{
  char nombre[15];
  float calificacion;
};

typedef struct Profesor profesor; //sinónimo

//Prototipos:
void readArray (profesor arr[], int n) 
{
    profesor * parr = arr; 
  for (int i=0; i<n; i++)
    {
      //scanf ("%s %lf", arr[i]->nombre, &arr[i]->calificacion);
      //gets(arr[i].nombre);
      scanf("%s", (parr+i)->nombre); //
      scanf ("%f", &(parr+i)->calificacion); //&parr[i].calificacion tmb funciona!
    }
};

/*
void mergeArrays (Profesor _____, int _____, Profesor ____, int _____,
		  Profesor _____, int ____);
*/
void sortArray (profesor parr[], int n) // ordena arrF (que contiene salida del merge)
{
    profesor * arr = parr;
    profesor aux; 
    for(int i=0; i<n; i++)
    {
        for(int k=0; k<n-1; k++)
        {
            if((arr+k)->calificacion<(arr+k+1)->calificacion)
            {
                aux.calificacion=(arr+k)->calificacion;
                strcpy(aux.nombre, (arr+k)->nombre);
                
                (arr+k)->calificacion=(arr+k+1)->calificacion;
                strcpy((arr+k)->nombre, (arr+k+1)->nombre);
                
                (arr+k+1)->calificacion=aux.calificacion;
                strcpy((arr+k+1)->nombre, aux.nombre);
            }
        }
    }
};

void printArray (profesor arr[], int n)
{
     for(int i=0; i<n; i++)
     {
     printf("%s\t", arr[i].nombre);
     printf("%.1f\n", arr[i].calificacion);
     }
};


void main ()
{
  profesor arr1[20];		//Primer arreglo (de estructuras tipo Prof)
  profesor arr2[20];		//Segundo arreglo
  profesor arrF[40];		//Arreglo final, con elementos fusionados y ordenados
  int n1, n2;			//Longitud de los arreglos

scanf("%d", &n1);
  readArray(arr1, n1);	//leer el primer arreglo
//scanf("%d", &n2);                                  //falla aquí
  //readArray (arr2, n2);	//leer el segundo arreglo 
  
  //mergeArrays (_______________________________);	//Fusionar los dos arreglos en un tercer arreglo - arrF

  //sortArray (_____________);	//Ordenar los elementos del tercer arreglo arrF, recuerde que pueden 
  //existir profesores repetidos (!)
  
  sortArray(arr1, n1); //extra!----

printArray(arr1, n1); //Imprimir el resultado final (arrF!)




  return 0;
}

/*

profesor p;
profesor * ap = p; 
ap->calificacion=7;
scanf("%f", &ap->calificacion); //& porque es variable, no lleva si fuese array

int v[]={1,2,3,4};
int *p=v; //no lleva & porque nombre del array representa dirección inicial 
*p++:
*p=*p+1;

p++
*/

original --------------------------------------------

#include <stdio.h>

typedef struct
{
  char nombre[15];
  float calificacion;
} Profesor;

float averageArray (Profesor ______, int _____);
void readArray (Profesor ________, int _____) //habría de recibir apuntador a sctruct tipo prof 
{
  for (int i = 0; i < n1; i++) //arr1
    {
      scanf ("%s", Profesor[i]->nombre);
      scanf ("%lf", Profesor[i]->calificación);
    }
    
  for (int i = 0; i < n2; i++) //arr2
    {
      scanf ("%s", Profesor[i]->nombre);
      scanf ("%lf", Profesor[i]->calificación);
    }


};

void mergeArrays (Profesor _____, int _____, Profesor ____, int _____,
		  Profesor _____, int ____);
void sortArray (Profesor _____, int ____);
void printArray (Profesor ____, int _____);


void
main ()
{
  Profesor arr1[20];		//Primer arreglo (de estructuras tipo Prof)
  Profesor arr2[20];		//Segundo arreglo
  Profesor arrF[40];		//Arreglo final, con elementos fusionados y ordenados
  int n1, n2;			//Longitud de los arreglos


scanf("%d", n1);
  readArray (______________);	//leer el primer arreglo
scanf("%d", n2); 
  readArray (______________);	//leer el segundo arreglo 
  mergeArrays (_______________________________);	//Fusionar los dos arreglos en un tercer arreglo

  sortArray (_____________);	//Ordenar los elementos del tercer arreglo, recuerde que pueden 
  //existir profesores repetidos

  printArray (___________);	//Imprimir el resultado final

  return 0;
}
